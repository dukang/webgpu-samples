{"version":3,"sources":["webpack:///./src/glslang.ts","webpack:///./src/examples/helloTriangle.ts","webpack:///./src/examples/helloTriangleMSAA.ts"],"names":["glslang","undefined","glslangModule","import","default","title","description","init","canvas","vertexShaderGLSL","fragmentShaderGLSL","adapter","navigator","gpu","requestAdapter","device","requestDevice","swapChain","getContext","configureSwapChain","format","pipeline","createRenderPipeline","layout","createPipelineLayout","bindGroupLayouts","vertexStage","module","createShaderModule","code","compileGLSL","source","transform","entryPoint","fragmentStage","primitiveTopology","colorStates","commandEncoder","createCommandEncoder","renderPassDescriptor","colorAttachments","attachment","getCurrentTexture","createView","loadValue","r","g","b","a","passEncoder","beginRenderPass","setPipeline","draw","endPass","defaultQueue","submit","finish","sampleCount","createTexture","size","width","height","depth","usage","GPUTextureUsage","OUTPUT_ATTACHMENT","resolveTarget"],"mappings":"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","file":"helloTriangle-d06e4b.js","sourcesContent":["let glslang = undefined;\nexport default async function() {\n  if (glslang !== undefined) return glslang;\n  // @ts-ignore\n  const glslangModule = await import(/* webpackIgnore: true */ 'https://unpkg.com/@webgpu/glslang@0.0.15/dist/web-devel/glslang.js');\n  glslang = await glslangModule.default();\n  return glslang;\n}\n","import glslangModule from '../glslang';\n\nexport const title = 'Hello Triangle';\nexport const description = 'Shows rendering a basic triangle.';\n\nexport async function init(canvas: HTMLCanvasElement) {\n    const vertexShaderGLSL = `#version 450\n      const vec2 pos[3] = vec2[3](vec2(0.0f, 0.5f), vec2(-0.5f, -0.5f), vec2(0.5f, -0.5f));\n\n      void main() {\n          gl_Position = vec4(pos[gl_VertexIndex], 0.0, 1.0);\n      }\n    `;\n\n    const fragmentShaderGLSL = `#version 450\n      layout(location = 0) out vec4 outColor;\n\n      void main() {\n          outColor = vec4(1.0, 0.0, 0.0, 1.0);\n      }\n    `;\n\n    const adapter = await navigator.gpu.requestAdapter();\n    const device = await adapter.requestDevice();\n    const glslang = await glslangModule();\n\n    const context = canvas.getContext('gpupresent');\n\n    const swapChainFormat = \"bgra8unorm\";\n\n    // @ts-ignore:\n    const swapChain: GPUSwapChain = context.configureSwapChain({\n      device,\n      format: swapChainFormat,\n    });\n\n    const pipeline = device.createRenderPipeline({\n      layout: device.createPipelineLayout({ bindGroupLayouts: [] }),\n\n      vertexStage: {\n        module: device.createShaderModule({\n          code: glslang.compileGLSL(vertexShaderGLSL, \"vertex\"),\n\n          // @ts-ignore\n          source: vertexShaderGLSL,\n          transform: source => glslang.compileGLSL(source, \"vertex\"),\n        }),\n        entryPoint: \"main\"\n      },\n      fragmentStage: {\n        module: device.createShaderModule({\n          code: glslang.compileGLSL(fragmentShaderGLSL, \"fragment\"),\n\n          // @ts-ignore\n          source: fragmentShaderGLSL,\n          transform: source => glslang.compileGLSL(source, \"fragment\"),\n        }),\n        entryPoint: \"main\"\n      },\n\n      primitiveTopology: \"triangle-list\",\n\n      colorStates: [{\n        format: swapChainFormat,\n      }],\n    });\n\n    function frame() {\n      const commandEncoder = device.createCommandEncoder({});\n      const textureView = swapChain.getCurrentTexture().createView();\n\n      const renderPassDescriptor: GPURenderPassDescriptor = {\n        colorAttachments: [{\n          attachment: textureView,\n          loadValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },\n        }],\n      };\n\n      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n      passEncoder.setPipeline(pipeline);\n      passEncoder.draw(3, 1, 0, 0);\n      passEncoder.endPass();\n\n      device.defaultQueue.submit([commandEncoder.finish()]);\n    }\n\n    return frame;\n}\n","import glslangModule from '../glslang';\n\nexport const title = 'Hello Triangle MSAA';\nexport const description = 'Shows rendering a basic triangle with multisampling.';\n\nexport async function init(canvas: HTMLCanvasElement) {\n    const vertexShaderGLSL = `#version 450\n      const vec2 pos[3] = vec2[3](vec2(0.0f, 0.5f), vec2(-0.5f, -0.5f), vec2(0.5f, -0.5f));\n\n      void main() {\n          gl_Position = vec4(pos[gl_VertexIndex], 0.0, 1.0);\n      }\n    `;\n\n    const fragmentShaderGLSL = `#version 450\n      layout(location = 0) out vec4 outColor;\n\n      void main() {\n          outColor = vec4(1.0, 0.0, 0.0, 1.0);\n      }\n    `;\n\n    const adapter = await navigator.gpu.requestAdapter();\n    const device = await adapter.requestDevice();\n    const glslang = await glslangModule();\n\n    const context = canvas.getContext('gpupresent');\n\n    const swapChainFormat = \"bgra8unorm\";\n\n    // @ts-ignore:\n    const swapChain: GPUSwapChain = context.configureSwapChain({\n      device,\n      format: swapChainFormat,\n    });\n\n    const sampleCount = 4;\n\n    const pipeline = device.createRenderPipeline({\n      layout: device.createPipelineLayout({ bindGroupLayouts: [] }),\n\n      vertexStage: {\n        module: device.createShaderModule({\n          code: glslang.compileGLSL(vertexShaderGLSL, \"vertex\"),\n\n          // @ts-ignore\n          source: vertexShaderGLSL,\n          transform: source => glslang.compileGLSL(source, \"vertex\"),\n        }),\n        entryPoint: \"main\"\n      },\n      fragmentStage: {\n        module: device.createShaderModule({\n          code: glslang.compileGLSL(fragmentShaderGLSL, \"fragment\"),\n\n          // @ts-ignore\n          source: fragmentShaderGLSL,\n          transform: source => glslang.compileGLSL(source, \"fragment\"),\n        }),\n        entryPoint: \"main\"\n      },\n\n      primitiveTopology: \"triangle-list\",\n\n      colorStates: [{\n        format: swapChainFormat,\n      }],\n\n      sampleCount,\n    });\n\n    const texture = device.createTexture({\n      size: {\n        width: canvas.width,\n        height: canvas.height,\n        depth: 1,\n      },\n      sampleCount,\n      format: swapChainFormat,\n      usage: GPUTextureUsage.OUTPUT_ATTACHMENT,\n    });\n    const attachment = texture.createView();\n\n    function frame() {\n      const commandEncoder = device.createCommandEncoder({});\n\n      const renderPassDescriptor: GPURenderPassDescriptor = {\n        colorAttachments: [{\n          attachment: attachment,\n          resolveTarget: swapChain.getCurrentTexture().createView(),\n          loadValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },\n        }],\n      };\n\n      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n      passEncoder.setPipeline(pipeline);\n      passEncoder.draw(3, 1, 0, 0);\n      passEncoder.endPass();\n\n      device.defaultQueue.submit([commandEncoder.finish()]);\n    }\n\n    return frame;\n}\n"],"sourceRoot":""}